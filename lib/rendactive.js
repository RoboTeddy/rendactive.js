// Generated by CoffeeScript 1.4.0
(function() {
  var createHandle;

  createHandle = function() {
    var eventBusMap, eventMap, handle;
    eventMap = {};
    eventBusMap = {};
    handle = {
      creates: new Bacon.Bus(),
      renders: new Bacon.Bus(),
      destroys: new Bacon.Bus(),
      events: function(eventSelector) {
        var bus;
        if (eventSelector in eventBusMap) {
          return eventBusMap[eventSelector];
        }
        bus = eventBusMap[eventSelector] = new Bacon.Bus();
        eventMap[eventSelector] = bus.push;
        return bus;
      },
      data: function(eventSelector, name) {
        return this.events(eventSelector).map(function(e) {
          return $(e.target).data(name);
        });
      },
      ids: function(eventSelector) {
        return this.data(eventSelector, 'id');
      },
      clicks: function(selector) {
        return this.events("click " + selector);
      },
      changes: function(selector) {
        return this.events("change " + selector);
      },
      enters: function(selector) {
        return this.events("keydown " + selector).filter(function(e) {
          return e.keyCode === 13;
        });
      },
      blurs: function(selector) {
        return this.events("blur " + selector);
      },
      checkboxBooleans: function(selector) {
        return this.events("change " + selector).map(function(e) {
          return $(e.target).is(":checked");
        });
      },
      inputValue: function(selector) {
        return this.events("keyup " + selector).map(function(e) {
          return $(e.target).val();
        }).toProperty('');
      },
      valueAfterRender: function(observable, f) {
        var _this = this;
        return observable.flatMap(function(v) {
          return _this.renders.take(1).map(v);
        }).onValue(function(v) {
          return f(v);
        });
      }
    };
    return {
      handle: handle,
      eventMap: eventMap
    };
  };

  this.rendactive = function(template, createDataTemplate) {
    var data, dataTemplate, destroy, eventMap, fragment, handle, latestData, mark, unsubscribe, _ref;
    _ref = createHandle(), handle = _ref.handle, eventMap = _ref.eventMap;
    dataTemplate = createDataTemplate(handle);
    data = Bacon.combineTemplate(dataTemplate);
    latestData = null;
    unsubscribe = data.onValue(function(v) {
      return latestData = v;
    });
    if (!latestData) {
      throw "Need initial values in all properties";
    }
    mark = null;
    fragment = Spark.render(function() {
      var landmarkOptions;
      landmarkOptions = {
        created: function() {
          mark = this;
          return handle.creates.push(this);
        },
        rendered: function() {
          return handle.renders.push(this);
        },
        destroyed: function() {
          unsubscribe();
          return handle.destroys.push(this);
        }
      };
      return Spark.createLandmark(landmarkOptions, function() {
        var html;
        html = Spark.isolate(function() {
          var ctx;
          ctx = Meteor.deps.Context.current;
          ctx.onInvalidate(data.changes().onValue(function() {
            return ctx.invalidate();
          }));
          return template(latestData);
        });
        return Spark.attachEvents(eventMap, html);
      });
    });
    destroy = function() {
      return mark && Spark.finalize(mark.firstNode(), mark.lastNode());
    };
    return {
      fragment: fragment,
      dataTemplate: dataTemplate,
      destroy: destroy
    };
  };

}).call(this);
